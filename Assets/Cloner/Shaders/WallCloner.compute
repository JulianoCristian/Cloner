// Cloner - An example of use of procedural instancing.
// https://github.com/keijiro/Cloner

#pragma kernel ClonerUpdate

#include "Common.hlsl"
#include "SimplexNoise2D.hlsl"

RWStructuredBuffer<float4> TransformBuffer;

CBUFFER_START(Params)

    uint InstanceCount;
    uint BufferStride;

    uint ColumnCount;
    uint RowCount;
    float2 Extent;
    float2 PositionOffset;

    int2 ScrollStep;

    float BaseScale;
    float ScaleNoise;
    float ScalePulse;

    float NoiseFrequency;
    float2 NoiseOffset;
    float PositionModifier;
    float NormalModifier;

    float PulseProbability;
    float PulseTime;

CBUFFER_END

[numthreads(128, 1, 1)]
void ClonerUpdate(uint id : SV_DispatchThreadID)
{
    if (id >= InstanceCount) return;

    // Unmodified position
    uint row = id / ColumnCount;
    uint col = id - row * ColumnCount;

    float2 p0 = float2(float(col) / ColumnCount, float(row) / RowCount);
    p0 = (p0 * 2 - 1) * Extent;

    // Dual noise field
    float2 np = p0 * NoiseFrequency;
    float3 sn1 = snoise_grad(98.4898 + np + NoiseOffset);
    float3 sn2 = snoise_grad( 1.2278 + np + NoiseOffset);

    // Position modification.
    float3 p = float3(p0 - PositionOffset, 0);
    p += sn1 * float3(0.2, 0.2, 1) * PositionModifier;

    // Normal modification.
    float3 nz = normalize(float3(sn2.xy * NormalModifier, 1));
    float3 ny = normalize(cross(nz, float3(1, 0, 0)));
    float3 nx = cross(nz, ny);

    // UV offsetting.
    uint hash = Hash(id);
    float uoffs = float(hash & 0xfff000) / 0x1000000;
    float voffs = float(hash & 0x000fff) / 0x0001000;
    float uvoffs = uoffs + floor(voffs * 1000);

    // Pulse noise.
    uint seed0 = (col + ScrollStep.x) * 131071 + (row + ScrollStep.y) * 8294;
    float ptime = PulseTime + Random(seed0);
    uint seed = (col + ScrollStep.x) * 131071 + (row + ScrollStep.y) * 8294 + (uint)ptime;
    float pulse0 = Random(seed + 0) < PulseProbability;
    float pulse1 = Random(seed + 1) < PulseProbability;
    float pulse = lerp(pulse0, pulse1, smoothstep(0, 1, frac(ptime)));

    // Scale factor.
    float scale = max(0, BaseScale + sn1.z * ScaleNoise) + pulse * ScalePulse;

    TransformBuffer[id + BufferStride * 0] = float4(p, scale);
    TransformBuffer[id + BufferStride * 1] = float4(nx, uvoffs);
    TransformBuffer[id + BufferStride * 2] = float4(ny, sn2.z);
}
