// Cloner - An example of use of procedural instancing.
// https://github.com/keijiro/Cloner

#pragma kernel ClonerUpdate

#include "Common.hlsl"
#include "SimplexNoise2D.hlsl"

RWStructuredBuffer<float4> TransformBuffer;

CBUFFER_START(Params)

    uint InstanceCount;
    uint BufferStride;

    uint2 Iteration;
    float2 Extent;
    float2 Scroll;

    float BaseScale;
    float ScaleNoise;
    float ScalePulse;

    float NoiseFrequency;
    float2 NoiseOffset;
    float PositionModifier;
    float NormalModifier;

    float PulseProbability;
    float PulseTime;

CBUFFER_END

[numthreads(128, 1, 1)]
void ClonerUpdate(uint id : SV_DispatchThreadID)
{
    if (id >= InstanceCount) return;

    // Column, Row
    int2 p_i = int2(id % Iteration.x, id / Iteration.x);

    // Normalized position
    float2 p_01 = (float2)p_i / Iteration;

    // Wrap-around count
    int2 wa_i = floor(p_01 + Scroll * 0.5 / Extent);

    // ID with wrapping around
    int id_wa = id + wa_i.x * Iteration.x + wa_i.y * Iteration.y;

    // Original position with wrapping around
    float2 p_wa = ((p_01 - wa_i) * 2 - 1) * Extent;

    // Noise field x2
    float3 sn1 = snoise_grad(98.4898 + p_wa * NoiseFrequency + NoiseOffset);
    float3 sn2 = snoise_grad( 1.2278 - p_wa * NoiseFrequency + NoiseOffset);

    // Position modification
    float3 p = float3(p_wa + Scroll, 0);
    p += sn1 * float3(0.2, 0.2, 1) * PositionModifier;

    // Normal modification
    float3 nz = normalize(float3(sn2.xy * NormalModifier, 1));
    float3 ny = normalize(cross(nz, float3(1, 0, 0)));
    float3 nx = cross(nz, ny);

    // UV offsetting
    uint hash = Hash(id_wa);
    float uoffs = float(hash & 0xfff000) / 0x1000000;
    float voffs = float(hash & 0x000fff) / 0x0001000;
    float uvoffs = uoffs + floor(voffs * 1000);

    // Pulse noise
    float ptime = PulseTime + (float)id_wa / InstanceCount;
    uint seed = id_wa * 131071 + (uint)ptime;
    float pulse0 = Random(seed + 0) < PulseProbability;
    float pulse1 = Random(seed + 1) < PulseProbability;
    float pulse = lerp(pulse0, pulse1, smoothstep(0, 1, frac(ptime)));

    // Scale factor
    float scale = max(0, BaseScale + sn1.z * ScaleNoise) + pulse * ScalePulse;

    TransformBuffer[id + BufferStride * 0] = float4(p, scale);
    TransformBuffer[id + BufferStride * 1] = float4(nx, uvoffs);
    TransformBuffer[id + BufferStride * 2] = float4(ny, sn2.z);
}
